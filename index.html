<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Multiplayer Blokus - 2 Players</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            max-width: 1400px;
            width: 100%;
        }

        /* Lobby Screen Styles */
        .lobby-screen {
            text-align: center;
            padding: 40px;
        }

        .lobby-screen h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        .lobby-screen p {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.2em;
        }

        .lobby-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .room-info {
            margin: 30px 0;
            padding: 20px;
            background: #f0f0f0;
            border-radius: 10px;
        }

        .room-code {
            font-size: 3em;
            font-weight: bold;
            color: #2196F3;
            letter-spacing: 10px;
            margin: 10px 0;
        }

        .join-input {
            padding: 15px;
            font-size: 1.5em;
            text-align: center;
            letter-spacing: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            width: 300px;
            max-width: 100%;
        }

        .waiting-message {
            color: #666;
            font-size: 1.2em;
            margin-top: 20px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .game-header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .version-badge {
            position: absolute;
            top: 0;
            right: 0;
            background: #4CAF50;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .room-code-display {
            background: #f0f0f0;
            padding: 10px 20px;
            border-radius: 10px;
            display: inline-block;
            margin-bottom: 10px;
        }

        .room-code-display strong {
            color: #2196F3;
            font-size: 1.5em;
            letter-spacing: 5px;
        }

        .game-info {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .player-info {
            padding: 15px 25px;
            border-radius: 10px;
            min-width: 200px;
            text-align: center;
            transition: all 0.3s;
        }

        .player-info.active {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .player-info.blue { background: #2196F3; color: white; }
        .player-info.red { background: #F44336; color: white; }

        .player-info .name {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .player-info .pieces-left {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .game-main {
            display: flex;
            gap: 30px;
            justify-content: center;
            align-items: flex-start;
        }

        .board-container {
            flex-shrink: 0;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(14, 30px);
            grid-template-rows: repeat(14, 30px);
            gap: 1px;
            background: #333;
            border: 3px solid #333;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .cell {
            background: white;
            width: 30px;
            height: 30px;
            position: relative;
            cursor: pointer;
        }

        .cell:hover {
            outline: 2px solid #ff0;
        }

        .cell.corner {
            background: #f0f0f0;
        }

        .cell.start-corner {
            position: relative;
            animation: pulse-corner 1.5s ease-in-out infinite;
        }

        .cell.start-corner::after {
            content: '‚òÖ';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: white;
            font-weight: bold;
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
        }

        @keyframes pulse-corner {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }

        .cell.filled {
            border: 1px solid rgba(0,0,0,0.1);
        }

        .cell.filled.blue { background: #2196F3; }
        .cell.filled.red { background: #F44336; }

        .cell.preview {
            opacity: 0.6;
            border: 3px solid rgba(0, 255, 0, 0.9) !important;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
            animation: preview-pulse 1s ease-in-out infinite;
        }

        .cell.invalid-preview {
            background: rgba(255, 0, 0, 0.5) !important;
            border: 3px solid rgba(255, 0, 0, 0.9) !important;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
            animation: invalid-pulse 0.5s ease-in-out infinite;
        }

        @keyframes preview-pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 0, 0.5); }
            50% { box-shadow: 0 0 15px rgba(0, 255, 0, 0.9); }
        }

        @keyframes invalid-pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 0, 0, 0.5); }
            50% { box-shadow: 0 0 15px rgba(255, 0, 0, 0.9); }
        }

        .pieces-container {
            flex: 1;
            max-width: 400px;
        }

        .pieces-container h2 {
            color: #333;
            margin-bottom: 15px;
        }

        .pieces-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            max-height: 600px;
            overflow-y: auto;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 10px;
        }

        .piece {
            background: white;
            border: 2px solid #ddd;
            border-radius: 5px;
            padding: 5px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .piece:hover:not(.used) {
            transform: scale(1.05);
            border-color: #666;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }

        .piece.selected {
            border-color: #333;
            border-width: 3px;
            background: #f0f0f0;
        }

        .piece.used {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .piece-shape {
            display: grid;
            gap: 1px;
        }

        .piece-cell {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .piece-cell.filled.blue { background: #2196F3; }
        .piece-cell.filled.red { background: #F44336; }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #2196F3;
            color: white;
        }

        .btn-secondary {
            background: #666;
            color: white;
        }

        .btn-success {
            background: #4CAF50;
            color: white;
        }

        .btn-danger {
            background: #F44336;
            color: white;
        }

        .message {
            margin: 15px 0;
            padding: 15px;
            border-radius: 5px;
            background: #f0f0f0;
            color: #333;
            font-weight: bold;
            text-align: center;
            font-size: 1.1em;
        }

        .message.opponent-turn {
            background: #fff3cd;
            color: #856404;
        }

        .message.your-turn {
            background: #d4edda;
            color: #155724;
        }

        .game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .game-over-modal.show {
            display: flex;
        }

        .game-over-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
        }

        .game-over-content h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #333;
        }

        .final-scores {
            margin: 20px 0;
        }

        .score-item {
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            font-size: 1.3em;
            font-weight: bold;
        }

        .hidden {
            display: none !important;
        }

        /* Mobile Optimization */
        @media screen and (max-width: 768px) {
            body {
                padding: 10px;
            }

            .game-container {
                padding: 15px;
            }

            .version-badge {
                font-size: 0.65em;
                padding: 3px 8px;
            }

            .game-header h1 {
                font-size: 1.8em;
            }

            .lobby-screen h1 {
                font-size: 2em;
            }

            .room-code {
                font-size: 2em;
                letter-spacing: 5px;
            }

            .join-input {
                font-size: 1.2em;
                letter-spacing: 5px;
                width: 250px;
            }

            .game-main {
                flex-direction: column;
                align-items: center;
            }

            .board {
                grid-template-columns: repeat(14, 22px);
                grid-template-rows: repeat(14, 22px);
            }

            .cell {
                width: 22px;
                height: 22px;
            }

            .cell.start-corner::after {
                font-size: 16px;
            }

            .pieces-container {
                max-width: 100%;
                width: 100%;
            }

            .pieces-grid {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                gap: 8px;
                max-height: 400px;
            }

            .btn {
                padding: 10px 16px;
                font-size: 0.95em;
            }
        }
    </style>
</head>
<body>
    <!-- Lobby Screen -->
    <div id="lobbyScreen" class="game-container lobby-screen">
        <div style="position: relative;">
            <span class="version-badge" style="position: absolute; top: 0; right: 0;">v1.5.0</span>
            <h1>Multiplayer Blokus</h1>
        </div>
        <p>2-Player Online Game</p>

        <div id="lobbyMain">
            <div class="lobby-buttons">
                <button class="btn btn-primary" onclick="createRoom()">Create Room</button>
                <button class="btn btn-success" onclick="showJoinInput()">Join Room</button>
            </div>
        </div>

        <div id="createRoomView" class="hidden">
            <div class="room-info">
                <h2>Room Created!</h2>
                <p>Share this code with your opponent:</p>
                <div class="room-code" id="displayRoomCode"></div>
                <p class="waiting-message">Waiting for opponent to join...</p>
            </div>
            <button class="btn btn-secondary" onclick="cancelRoom()">Cancel</button>
        </div>

        <div id="joinRoomView" class="hidden">
            <div class="room-info">
                <h2>Join Room</h2>
                <p>Enter the 6-digit room code:</p>
                <input type="text" id="roomCodeInput" class="join-input" maxlength="6" placeholder="000000">
                <br><br>
                <button class="btn btn-primary" onclick="joinRoom()">Join</button>
                <button class="btn btn-secondary" onclick="cancelJoin()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="game-container hidden">
        <div class="game-header">
            <span class="version-badge">v1.5.0</span>
            <h1>Multiplayer Blokus</h1>
            <div class="room-code-display">
                Room Code: <strong id="gameRoomCode"></strong>
            </div>
        </div>

        <div class="game-info" id="playersInfo">
            <!-- Players info will be inserted here -->
        </div>

        <div class="message" id="messageBox">Game starting...</div>

        <div class="game-main">
            <div class="board-container">
                <div class="board" id="gameBoard">
                    <!-- Board cells will be inserted here -->
                </div>
            </div>

            <div class="pieces-container" id="piecesContainer">
                <h2>Your Pieces</h2>
                <div class="controls">
                    <button class="btn btn-primary" onclick="rotatePiece()">Rotate</button>
                    <button class="btn btn-secondary" onclick="flipPiece()">Flip</button>
                    <button class="btn btn-secondary" onclick="deselectPiece()">Deselect</button>
                </div>
                <div class="pieces-grid" id="piecesGrid">
                    <!-- Pieces will be inserted here -->
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-success" onclick="skipTurn()" id="skipBtn">Skip Turn</button>
            <button class="btn btn-danger" onclick="leaveGame()">Leave Game</button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="game-over-modal" id="gameOverModal">
        <div class="game-over-content">
            <h2>Game Over!</h2>
            <div class="final-scores" id="finalScores">
                <!-- Final scores will be inserted here -->
            </div>
            <button class="btn btn-success" onclick="backToLobby()">Back to Lobby</button>
        </div>
    </div>

    <!-- Firebase SDK (CDN version 10.x) -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js';
        import { getDatabase, ref, set, get, onValue, update, remove, push, onDisconnect } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js';

        // ============================================================================
        // FIREBASE CONFIGURATION
        // ============================================================================
        // Firebase configuration from Firebase Console
        const firebaseConfig = {
            apiKey: "AIzaSyCTKozVj0JPFO6xznNWufmCstCxhz4rF1M",
            authDomain: "multi-blockers.firebaseapp.com",
            databaseURL: "https://multi-blockers-default-rtdb.firebaseio.com",
            projectId: "multi-blockers",
            storageBucket: "multi-blockers.firebasestorage.app",
            messagingSenderId: "40634277440",
            appId: "1:40634277440:web:19d35df1b8a4c2aae589a5",
            measurementId: "G-9G4CPH8KS3"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Make Firebase functions globally accessible
        window.firebaseDB = {
            ref: ref,
            set: set,
            get: get,
            onValue: onValue,
            update: update,
            remove: remove,
            push: push,
            onDisconnect: onDisconnect,
            database: database
        };

        console.log('Firebase initialized successfully');
    </script>

    <script>
        // ============================================================================
        // BLOKUS PIECE DEFINITIONS (21 polyominoes)
        // ============================================================================
        const PIECE_SHAPES = [
            [[1]], // 1 square
            [[1,1]], // 2 squares
            [[1,1,1]], // 3 squares - line
            [[1,1],[1,0]], // 3 squares - L
            [[1,1,1,1]], // 4 squares - line
            [[1,1,1],[1,0,0]], // 4 squares - L
            [[1,1,1],[0,1,0]], // 4 squares - T
            [[1,1,0],[0,1,1]], // 4 squares - Z
            [[1,1],[1,1]], // 4 squares - square
            [[1,1,1,1,1]], // 5 squares - line
            [[1,1,1,1],[1,0,0,0]], // 5 squares - L
            [[1,1,1,1],[0,0,0,1]], // 5 squares - L mirror
            [[1,1,1],[1,1,0]], // 5 squares - P
            [[1,1,1],[0,1,1]], // 5 squares - P mirror
            [[1,1,1],[0,1,0],[0,1,0]], // 5 squares - T
            [[1,1,0],[0,1,0],[0,1,1]], // 5 squares - Z
            [[0,1,0],[1,1,1],[0,1,0]], // 5 squares - +
            [[1,1,1],[1,0,1]], // 5 squares - U
            [[1,1,0],[0,1,1],[0,0,1]], // 5 squares - W
            [[0,1,1],[1,1,0],[1,0,0]], // 5 squares - N
            [[1,0,0],[1,1,1],[0,0,1]], // 5 squares - Y
        ];

        // ============================================================================
        // GAME STATE
        // ============================================================================
        const game = {
            roomCode: null,
            playerId: null, // 0 (blue) or 1 (red)
            playerColor: null, // 'blue' or 'red'
            isHost: false,
            board: Array(14).fill(null).map(() => Array(14).fill(null)),
            players: [
                { name: 'Player 1', color: 'blue', pieces: [], cornerX: 0, cornerY: 0 },
                { name: 'Player 2', color: 'red', pieces: [], cornerX: 13, cornerY: 13 }
            ],
            currentPlayerIndex: 0,
            selectedPieceIndex: null,
            gameStarted: false,
            passCount: 0,
            dbListener: null
        };

        let lastPreviewCells = [];

        // ============================================================================
        // FIREBASE ROOM MANAGEMENT
        // ============================================================================

        // Generate a random 6-digit room code
        function generateRoomCode() {
            return Math.floor(100000 + Math.random() * 900000).toString();
        }

        // Create a new room
        async function createRoom() {
            const roomCode = generateRoomCode();
            const roomRef = window.firebaseDB.ref(window.firebaseDB.database, `rooms/${roomCode}`);

            // Initialize pieces for both players (create separate copies)
            // Store shapeIndex instead of shape array to avoid Firebase serialization issues
            const createInitialPieces = () => PIECE_SHAPES.map((shape, index) => ({
                shapeIndex: index,
                used: false,
                rotation: 0,
                flipped: false
            }));

            const roomData = {
                host: true,
                players: {
                    0: { connected: true, color: 'blue', name: 'Player 1' },
                    1: { connected: false, color: 'red', name: 'Player 2' }
                },
                gameState: {
                    board: Array(14).fill(null).map(() => Array(14).fill(null)),
                    pieces: {
                        0: createInitialPieces(),
                        1: createInitialPieces()
                    },
                    currentPlayerIndex: 0,
                    passCount: 0,
                    gameStarted: false,
                    gameOver: false
                },
                createdAt: Date.now()
            };

            try {
                await window.firebaseDB.set(roomRef, roomData);

                // Set up disconnect handler - remove room if host disconnects
                const connectedRef = window.firebaseDB.ref(window.firebaseDB.database, `rooms/${roomCode}/players/0/connected`);
                window.firebaseDB.onDisconnect(connectedRef).remove();
                window.firebaseDB.onDisconnect(roomRef).remove();

                game.roomCode = roomCode;
                game.playerId = 0;
                game.playerColor = 'blue';
                game.isHost = true;

                // Show room code to user
                document.getElementById('displayRoomCode').textContent = roomCode;
                document.getElementById('lobbyMain').classList.add('hidden');
                document.getElementById('createRoomView').classList.remove('hidden');

                // Listen for opponent joining
                listenForOpponent(roomCode);

                console.log(`Room created: ${roomCode}`);
            } catch (error) {
                console.error('Error creating room:', error);
                alert('Failed to create room. Please check Firebase configuration.');
            }
        }

        // Listen for opponent joining
        function listenForOpponent(roomCode) {
            const player1Ref = window.firebaseDB.ref(window.firebaseDB.database, `rooms/${roomCode}/players/1/connected`);

            window.firebaseDB.onValue(player1Ref, (snapshot) => {
                if (snapshot.val() === true) {
                    console.log('Opponent joined!');
                    startGame();
                }
            });
        }

        // Show join room input
        function showJoinInput() {
            document.getElementById('lobbyMain').classList.add('hidden');
            document.getElementById('joinRoomView').classList.remove('hidden');
            document.getElementById('roomCodeInput').focus();
        }

        // Join an existing room
        async function joinRoom() {
            const roomCode = document.getElementById('roomCodeInput').value.trim();

            if (roomCode.length !== 6) {
                alert('Please enter a valid 6-digit room code');
                return;
            }

            const roomRef = window.firebaseDB.ref(window.firebaseDB.database, `rooms/${roomCode}`);

            try {
                const snapshot = await window.firebaseDB.get(roomRef);

                if (!snapshot.exists()) {
                    alert('Room not found. Please check the code.');
                    return;
                }

                const roomData = snapshot.val();

                if (roomData.players[1].connected) {
                    alert('Room is full.');
                    return;
                }

                // Join as player 1 (red)
                const player1Ref = window.firebaseDB.ref(window.firebaseDB.database, `rooms/${roomCode}/players/1`);
                await window.firebaseDB.update(player1Ref, { connected: true });

                // Set up disconnect handler
                const connectedRef = window.firebaseDB.ref(window.firebaseDB.database, `rooms/${roomCode}/players/1/connected`);
                window.firebaseDB.onDisconnect(connectedRef).set(false);

                game.roomCode = roomCode;
                game.playerId = 1;
                game.playerColor = 'red';
                game.isHost = false;

                console.log(`Joined room: ${roomCode}`);

                startGame();
            } catch (error) {
                console.error('Error joining room:', error);
                alert('Failed to join room. Please try again.');
            }
        }

        // Cancel room creation
        async function cancelRoom() {
            if (game.roomCode) {
                const roomRef = window.firebaseDB.ref(window.firebaseDB.database, `rooms/${game.roomCode}`);
                await window.firebaseDB.remove(roomRef);
            }

            document.getElementById('createRoomView').classList.add('hidden');
            document.getElementById('lobbyMain').classList.remove('hidden');
            game.roomCode = null;
        }

        // Cancel join
        function cancelJoin() {
            document.getElementById('joinRoomView').classList.add('hidden');
            document.getElementById('lobbyMain').classList.remove('hidden');
            document.getElementById('roomCodeInput').value = '';
        }

        // ============================================================================
        // GAME START & FIREBASE SYNC
        // ============================================================================

        // Start the game
        async function startGame() {
            // Hide lobby, show game
            document.getElementById('lobbyScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            document.getElementById('gameRoomCode').textContent = game.roomCode;

            // Initialize game
            initializePieces();
            renderBoard();
            renderPlayersInfo();
            renderPieces();

            // Start listening to game state changes
            listenToGameState();

            // If host, mark game as started
            if (game.isHost) {
                const gameStateRef = window.firebaseDB.ref(window.firebaseDB.database, `rooms/${game.roomCode}/gameState/gameStarted`);
                await window.firebaseDB.set(gameStateRef, true);
            }

            game.gameStarted = true;
            updateMessage();
        }

        // Listen to real-time game state changes from Firebase
        function listenToGameState() {
            const gameStateRef = window.firebaseDB.ref(window.firebaseDB.database, `rooms/${game.roomCode}/gameState`);

            game.dbListener = window.firebaseDB.onValue(gameStateRef, (snapshot) => {
                const state = snapshot.val();
                if (!state) return;

                console.log('üîÑ Firebase state received:', state);

                // Update local game state
                // Firebase converts arrays to objects, so we need to convert them back
                // Use Array.from with map to ensure proper array conversion
                game.board = Array.from({ length: 14 }, (_, i) =>
                    Array.from({ length: 14 }, (__, j) => state.board[i]?.[j] ?? null)
                );

                game.currentPlayerIndex = state.currentPlayerIndex;
                game.passCount = state.passCount;

                // Update pieces - ensure proper array conversion with correct indices
                const pieces0 = state.pieces[0] || state.pieces['0'] || {};
                const pieces1 = state.pieces[1] || state.pieces['1'] || {};

                game.players[0].pieces = Array.from({ length: 21 }, (_, i) => pieces0[i]).filter(p => p);
                game.players[1].pieces = Array.from({ length: 21 }, (_, i) => pieces1[i]).filter(p => p);

                console.log('‚úÖ Local game state updated:', {
                    board: game.board,
                    player0Pieces: game.players[0].pieces.length,
                    player1Pieces: game.players[1].pieces.length,
                    currentPlayerIndex: game.currentPlayerIndex,
                    myPlayerId: game.playerId,
                    isMyTurn: game.currentPlayerIndex === game.playerId
                });

                // Update UI
                renderBoard();
                renderPlayersInfo();
                renderPieces();
                updateMessage();

                // Check for game over
                if (state.gameOver) {
                    endGame();
                }
            });

            // Listen for opponent disconnection
            const opponentId = game.playerId === 0 ? 1 : 0;
            const opponentRef = window.firebaseDB.ref(window.firebaseDB.database, `rooms/${game.roomCode}/players/${opponentId}/connected`);
            window.firebaseDB.onValue(opponentRef, (snapshot) => {
                if (snapshot.val() === false && game.gameStarted) {
                    alert('ÏÉÅÎåÄÎ∞©Ïù¥ Í≤åÏûÑÏùÑ Îñ†ÎÇ¨ÏäµÎãàÎã§.');
                    backToLobby();
                }
            });
        }

        // Sync game state to Firebase
        async function syncGameState() {
            if (!game.roomCode) return;

            const gameStateRef = window.firebaseDB.ref(window.firebaseDB.database, `rooms/${game.roomCode}/gameState`);

            await window.firebaseDB.update(gameStateRef, {
                board: game.board,
                currentPlayerIndex: game.currentPlayerIndex,
                passCount: game.passCount,
                pieces: {
                    0: game.players[0].pieces,
                    1: game.players[1].pieces
                }
            });
        }

        // ============================================================================
        // PIECE MANAGEMENT
        // ============================================================================

        function initializePieces() {
            game.players.forEach(player => {
                player.pieces = PIECE_SHAPES.map((shape, index) => ({
                    shapeIndex: index,
                    used: false,
                    rotation: 0,
                    flipped: false
                }));
            });
        }

        function rotateShape(shape) {
            // Create completely new array to avoid mutations
            const rows = shape.length;
            const cols = shape[0].length;
            const rotated = [];

            for (let c = 0; c < cols; c++) {
                rotated[c] = [];
                for (let r = 0; r < rows; r++) {
                    rotated[c][r] = shape[rows - 1 - r][c];
                }
            }
            return rotated;
        }

        function flipShape(shape) {
            // Create completely new array to avoid mutations
            return shape.map(row => [...row].reverse());
        }

        function getCurrentShape(piece) {
            // Get base shape from PIECE_SHAPES using shapeIndex
            // Always create a fresh deep copy
            let shape = JSON.parse(JSON.stringify(PIECE_SHAPES[piece.shapeIndex]));

            console.log('üîß Getting shape for piece:', {
                shapeIndex: piece.shapeIndex,
                rotation: piece.rotation,
                flipped: piece.flipped,
                originalShape: PIECE_SHAPES[piece.shapeIndex]
            });

            if (piece.flipped) {
                shape = flipShape(shape);
                console.log('After flip:', shape);
            }

            for (let i = 0; i < (piece.rotation % 4); i++) {
                shape = rotateShape(shape);
                console.log(`After rotation ${i + 1}:`, shape);
            }

            console.log('Final shape:', shape);
            return shape;
        }

        // ============================================================================
        // RENDERING FUNCTIONS
        // ============================================================================

        function renderBoard() {
            const boardElement = document.getElementById('gameBoard');
            const isFirstRender = boardElement.children.length === 0;

            if (isFirstRender) {
                boardElement.innerHTML = '';

                // Event delegation
                boardElement.addEventListener('click', (e) => {
                    const cell = e.target.closest('.cell');
                    if (cell) {
                        const row = parseInt(cell.dataset.row);
                        const col = parseInt(cell.dataset.col);
                        handleCellClick(row, col);
                    }
                });

                // Desktop: mouseover
                boardElement.addEventListener('mouseover', (e) => {
                    const cell = e.target.closest('.cell');
                    if (cell) {
                        const row = parseInt(cell.dataset.row);
                        const col = parseInt(cell.dataset.col);
                        showPreview(row, col);
                    }
                });

                // Mobile: touchstart
                boardElement.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    const cell = element?.closest('.cell');
                    if (cell) {
                        const row = parseInt(cell.dataset.row);
                        const col = parseInt(cell.dataset.col);
                        showPreview(row, col);
                    }
                }, { passive: true });

                // Mobile: touchmove
                boardElement.addEventListener('touchmove', (e) => {
                    const touch = e.touches[0];
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    const cell = element?.closest('.cell');
                    if (cell) {
                        const row = parseInt(cell.dataset.row);
                        const col = parseInt(cell.dataset.col);
                        showPreview(row, col);
                    }
                }, { passive: true });

                // Create cells
                for (let r = 0; r < 14; r++) {
                    for (let c = 0; c < 14; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;

                        // Mark corners
                        if ((r === 0 && c === 0) || (r === 13 && c === 13)) {
                            cell.classList.add('corner');
                        }

                        boardElement.appendChild(cell);
                    }
                }
            }

            // Update cell states
            for (let r = 0; r < 14; r++) {
                for (let c = 0; c < 14; c++) {
                    const cell = boardElement.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (!cell) continue;

                    cell.className = 'cell';

                    // Corners
                    if ((r === 0 && c === 0) || (r === 13 && c === 13)) {
                        cell.classList.add('corner');
                    }

                    // Highlight starting corner for current player's first piece
                    const currentPlayer = game.players[game.currentPlayerIndex];
                    const isFirstPiece = currentPlayer && currentPlayer.pieces.every(p => !p.used);

                    if (isFirstPiece && game.currentPlayerIndex === game.playerId &&
                        r === currentPlayer.cornerY && c === currentPlayer.cornerX) {
                        cell.classList.add('start-corner');
                        cell.style.background = currentPlayer.color === 'blue' ? '#2196F3' : '#F44336';
                        cell.style.opacity = '0.5';
                    }

                    // Filled cells
                    if (game.board[r][c]) {
                        cell.classList.add('filled', game.board[r][c]);
                    }
                }
            }
        }

        function renderPlayersInfo() {
            const playersInfo = document.getElementById('playersInfo');
            playersInfo.innerHTML = '';

            game.players.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = `player-info ${player.color}`;
                if (index === game.currentPlayerIndex) {
                    playerDiv.classList.add('active');
                }

                const usedPieces = player.pieces.filter(p => p.used).length;
                const totalSquares = player.pieces.reduce((sum, piece) => {
                    if (!piece.used) {
                        const shape = PIECE_SHAPES[piece.shapeIndex];
                        return sum + shape.flat().filter(cell => cell === 1).length;
                    }
                    return sum;
                }, 0);

                const playerLabel = index === game.playerId ? 'You' : 'Opponent';

                playerDiv.innerHTML = `
                    <div class="name">${playerLabel} (${player.color})</div>
                    <div class="pieces-left">Pieces: ${21 - usedPieces}/21</div>
                    <div class="pieces-left">Squares left: ${totalSquares}</div>
                `;

                playersInfo.appendChild(playerDiv);
            });
        }

        function renderPieces() {
            const piecesGrid = document.getElementById('piecesGrid');
            piecesGrid.innerHTML = '';

            const currentPlayer = game.players[game.playerId];
            const isMyTurn = game.currentPlayerIndex === game.playerId;

            console.log('üé® Rendering pieces - My turn:', isMyTurn, 'Player:', game.playerId, 'Current:', game.currentPlayerIndex);

            // Always show player's own pieces, but disable interaction when not their turn
            if (!currentPlayer || !currentPlayer.pieces || currentPlayer.pieces.length === 0) {
                console.log('‚ö†Ô∏è No pieces to render');
                piecesGrid.innerHTML = '<p style="padding: 20px; text-align: center; color: #666;">Loading pieces...</p>';
                return;
            }

            currentPlayer.pieces.forEach((piece, index) => {
                if (!piece || piece.shapeIndex === undefined) {
                    console.log('‚ö†Ô∏è Invalid piece at index', index, piece);
                    return;
                }

                const pieceDiv = document.createElement('div');
                pieceDiv.className = 'piece';
                if (piece.used) {
                    pieceDiv.classList.add('used');
                }
                if (game.selectedPieceIndex === index) {
                    pieceDiv.classList.add('selected');
                }

                const shape = getCurrentShape(piece);
                const shapeDiv = document.createElement('div');
                shapeDiv.className = 'piece-shape';
                shapeDiv.style.gridTemplateColumns = `repeat(${shape[0].length}, 12px)`;
                shapeDiv.style.gridTemplateRows = `repeat(${shape.length}, 12px)`;

                shape.forEach(row => {
                    row.forEach(cell => {
                        const cellDiv = document.createElement('div');
                        cellDiv.className = 'piece-cell';
                        if (cell === 1) {
                            cellDiv.classList.add('filled', currentPlayer.color);
                        }
                        shapeDiv.appendChild(cellDiv);
                    });
                });

                pieceDiv.appendChild(shapeDiv);
                // Only allow clicking if it's the player's turn and piece is not used
                if (!piece.used && isMyTurn) {
                    pieceDiv.addEventListener('click', () => selectPiece(index));
                    pieceDiv.style.cursor = 'pointer';
                } else if (!isMyTurn) {
                    pieceDiv.style.opacity = '0.5';
                    pieceDiv.style.cursor = 'not-allowed';
                }

                piecesGrid.appendChild(pieceDiv);
            });
        }

        function updateMessage() {
            const messageBox = document.getElementById('messageBox');
            const isMyTurn = game.currentPlayerIndex === game.playerId;

            if (isMyTurn) {
                messageBox.textContent = 'Your turn! Select a piece and place it on the board.';
                messageBox.className = 'message your-turn';
            } else {
                messageBox.textContent = "Opponent's turn. Please wait...";
                messageBox.className = 'message opponent-turn';
            }
        }

        function showMessage(message) {
            const messageBox = document.getElementById('messageBox');
            if (messageBox) {
                messageBox.textContent = message;
                console.log('Message:', message);
            }
        }

        // ============================================================================
        // PIECE INTERACTION
        // ============================================================================

        function selectPiece(index) {
            console.log('üñ±Ô∏è Piece selected:', index, 'Current player:', game.currentPlayerIndex, 'My ID:', game.playerId);

            if (game.currentPlayerIndex !== game.playerId) {
                showMessage('‚ùå ÏÉÅÎåÄÎ∞©Ïùò ÌÑ¥ÏûÖÎãàÎã§!');
                return;
            }

            const currentPlayer = game.players[game.playerId];
            if (currentPlayer.pieces[index].used) {
                showMessage('‚ùå Ïù¥ÎØ∏ ÏÇ¨Ïö©Ìïú Ï°∞Í∞ÅÏûÖÎãàÎã§.');
                return;
            }

            game.selectedPieceIndex = index;

            const isFirstPiece = currentPlayer.pieces.every(p => !p.used);
            if (isFirstPiece) {
                showMessage('‚úÖ Ï°∞Í∞Å ÏÑ†ÌÉùÎê®! ÏãúÏûë Î™®ÏÑúÎ¶¨(‚òÖ)Î•º ÎçÆÎèÑÎ°ù Î∞∞ÏπòÌïòÏÑ∏Ïöî.');
            } else {
                showMessage('‚úÖ Ï°∞Í∞Å ÏÑ†ÌÉùÎê®! Í∞ôÏùÄ ÏÉâ Ï°∞Í∞ÅÏùò Íº≠ÏßÄÏ†êÏóê ÎãøÎèÑÎ°ù Î∞∞ÏπòÌïòÏÑ∏Ïöî.');
            }

            console.log('‚úÖ Piece selected successfully:', {
                index,
                shape: getCurrentShape(currentPlayer.pieces[index]),
                rotation: currentPlayer.pieces[index].rotation,
                flipped: currentPlayer.pieces[index].flipped
            });

            renderPieces();
            renderBoard();
        }

        function deselectPiece() {
            game.selectedPieceIndex = null;
            clearPreview();
            renderPieces();
            renderBoard();
        }

        function rotatePiece() {
            if (game.selectedPieceIndex === null) return;
            if (game.currentPlayerIndex !== game.playerId) return;

            const currentPlayer = game.players[game.playerId];
            const piece = currentPlayer.pieces[game.selectedPieceIndex];
            piece.rotation = (piece.rotation + 1) % 4;

            clearPreview();
            renderPieces();
        }

        function flipPiece() {
            if (game.selectedPieceIndex === null) return;
            if (game.currentPlayerIndex !== game.playerId) return;

            const currentPlayer = game.players[game.playerId];
            const piece = currentPlayer.pieces[game.selectedPieceIndex];
            piece.flipped = !piece.flipped;

            clearPreview();
            renderPieces();
        }

        function clearPreview() {
            lastPreviewCells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);

                if (!game.board[r][c]) {
                    cell.className = 'cell';

                    if ((r === 0 && c === 0) || (r === 13 && c === 13)) {
                        cell.classList.add('corner');
                    }

                    const currentPlayer = game.players[game.currentPlayerIndex];
                    const isFirstPiece = currentPlayer && currentPlayer.pieces.every(p => !p.used);

                    if (isFirstPiece && game.currentPlayerIndex === game.playerId &&
                        r === currentPlayer.cornerY && c === currentPlayer.cornerX) {
                        cell.classList.add('start-corner');
                        cell.style.background = currentPlayer.color === 'blue' ? '#2196F3' : '#F44336';
                        cell.style.opacity = '0.5';
                    }
                }
            });
            lastPreviewCells = [];
        }

        // ============================================================================
        // GAME LOGIC - PLACEMENT VALIDATION
        // ============================================================================

        function isValidPlacement(playerIndex, shape, row, col) {
            const player = game.players[playerIndex];
            const color = player.color;

            // Check board bounds
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[0].length; c++) {
                    if (shape[r][c] === 1) {
                        const boardR = row + r;
                        const boardC = col + c;

                        if (boardR < 0 || boardR >= 14 || boardC < 0 || boardC >= 14) {
                            return false;
                        }

                        if (game.board[boardR][boardC] !== null) {
                            return false;
                        }
                    }
                }
            }

            // Check if first piece
            const isFirstPiece = player.pieces.every(p => !p.used);

            if (isFirstPiece) {
                // First piece must cover starting corner
                let coversCorner = false;
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[0].length; c++) {
                        if (shape[r][c] === 1) {
                            const boardR = row + r;
                            const boardC = col + c;
                            if (boardR === player.cornerY && boardC === player.cornerX) {
                                coversCorner = true;
                            }
                        }
                    }
                }
                return coversCorner;
            }

            // Check for edge contact (not allowed) and corner contact (required)
            let touchesSameColorEdge = false;
            let touchesSameColorCorner = false;

            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[0].length; c++) {
                    if (shape[r][c] === 1) {
                        const boardR = row + r;
                        const boardC = col + c;

                        // Check edges
                        const edges = [
                            [boardR - 1, boardC],
                            [boardR + 1, boardC],
                            [boardR, boardC - 1],
                            [boardR, boardC + 1]
                        ];

                        for (const [er, ec] of edges) {
                            if (er >= 0 && er < 14 && ec >= 0 && ec < 14) {
                                if (game.board[er][ec] === color) {
                                    touchesSameColorEdge = true;
                                }
                            }
                        }

                        // Check corners
                        const corners = [
                            [boardR - 1, boardC - 1],
                            [boardR - 1, boardC + 1],
                            [boardR + 1, boardC - 1],
                            [boardR + 1, boardC + 1]
                        ];

                        for (const [cr, cc] of corners) {
                            if (cr >= 0 && cr < 14 && cc >= 0 && cc < 14) {
                                if (game.board[cr][cc] === color) {
                                    touchesSameColorCorner = true;
                                }
                            }
                        }
                    }
                }
            }

            if (touchesSameColorEdge) {
                return false;
            }

            if (!touchesSameColorCorner) {
                return false;
            }

            return true;
        }

        // ============================================================================
        // PREVIEW SYSTEM
        // ============================================================================

        function showPreview(row, col) {
            clearPreview();

            if (game.selectedPieceIndex === null) return;
            if (game.currentPlayerIndex !== game.playerId) return;

            const currentPlayer = game.players[game.playerId];
            const piece = currentPlayer.pieces[game.selectedPieceIndex];
            const shape = getCurrentShape(piece);

            const valid = isValidPlacement(game.playerId, shape, row, col);

            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[0].length; c++) {
                    if (shape[r][c] === 1) {
                        const boardR = row + r;
                        const boardC = col + c;

                        if (boardR >= 0 && boardR < 14 && boardC >= 0 && boardC < 14) {
                            const cell = document.querySelector(`[data-row="${boardR}"][data-col="${boardC}"]`);
                            if (cell && !game.board[boardR][boardC]) {
                                cell.classList.add('filled', currentPlayer.color, 'preview');
                                if (!valid) {
                                    cell.classList.add('invalid-preview');
                                }
                                lastPreviewCells.push(cell);
                            }
                        }
                    }
                }
            }
        }

        // ============================================================================
        // PIECE PLACEMENT & TURN MANAGEMENT
        // ============================================================================

        async function handleCellClick(row, col) {
            console.log('üñ±Ô∏è Cell clicked:', row, col);
            console.log('üìä Game state:', {
                currentPlayerIndex: game.currentPlayerIndex,
                myPlayerId: game.playerId,
                selectedPieceIndex: game.selectedPieceIndex,
                isMyTurn: game.currentPlayerIndex === game.playerId
            });

            // Show preview on click first (for mobile feedback)
            showPreview(row, col);

            // Only allow placement on your turn
            if (game.currentPlayerIndex !== game.playerId) {
                showMessage('‚ùå ÏÉÅÎåÄÎ∞©Ïùò ÌÑ¥ÏûÖÎãàÎã§!');
                console.log('‚ùå Not your turn');
                // Clear preview after a moment so user sees the red preview
                setTimeout(clearPreview, 800);
                return;
            }

            if (game.selectedPieceIndex === null) {
                showMessage('‚ö†Ô∏è Î®ºÏ†Ä Ïò§Î•∏Ï™ΩÏóêÏÑú Ï°∞Í∞ÅÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî!');
                console.log('‚ö†Ô∏è No piece selected');
                clearPreview();
                return;
            }

            const currentPlayer = game.players[game.playerId];
            const piece = currentPlayer.pieces[game.selectedPieceIndex];
            const shape = getCurrentShape(piece);

            console.log('üîç Validating placement:', {
                row, col,
                shape,
                rotation: piece.rotation,
                flipped: piece.flipped
            });

            if (!isValidPlacement(game.playerId, shape, row, col)) {
                const isFirstPiece = currentPlayer.pieces.every(p => !p.used);
                if (isFirstPiece) {
                    showMessage('‚ùå Ï≤´ Ï°∞Í∞ÅÏùÄ ÏãúÏûë Î™®ÏÑúÎ¶¨(‚òÖ)Î•º ÎçÆÏñ¥Ïïº Ìï©ÎãàÎã§!');
                } else {
                    showMessage('‚ùå Ï°∞Í∞ÅÏùÄ Í∞ôÏùÄ ÏÉâÍ≥º Íº≠ÏßÄÏ†êÏúºÎ°úÎßå ÎãøÏïÑÏïº ÌïòÍ≥†, Î≥ÄÏúºÎ°úÎäî ÎãøÏúºÎ©¥ ÏïàÎê©ÎãàÎã§!');
                }
                console.log('‚ùå Invalid placement');
                // Keep the red preview for a moment so user sees why it failed
                setTimeout(clearPreview, 800);
                return;
            }

            // Place piece on board
            console.log('‚úÖ Placing piece at:', row, col);
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[0].length; c++) {
                    if (shape[r][c] === 1) {
                        game.board[row + r][col + c] = currentPlayer.color;
                    }
                }
            }

            piece.used = true;
            const oldSelectedIndex = game.selectedPieceIndex;
            game.selectedPieceIndex = null;
            game.passCount = 0;

            // Switch turn
            const oldPlayerIndex = game.currentPlayerIndex;
            game.currentPlayerIndex = (game.currentPlayerIndex + 1) % 2;

            console.log('üîÑ Turn switched:', oldPlayerIndex, '‚Üí', game.currentPlayerIndex);

            // Sync to Firebase - UI will update via listener
            try {
                await syncGameState();
                showMessage('‚úÖ Ï°∞Í∞Å Î∞∞Ïπò ÏÑ±Í≥µ!');
                console.log('‚úÖ Successfully synced to Firebase');
            } catch (error) {
                console.error('‚ùå Failed to sync game state:', error);
                showMessage('‚ùå ÎèôÍ∏∞Ìôî Ïã§Ìå®. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
                // Rollback
                piece.used = false;
                game.selectedPieceIndex = oldSelectedIndex;
                game.currentPlayerIndex = oldPlayerIndex;
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[0].length; c++) {
                        if (shape[r][c] === 1) {
                            game.board[row + r][col + c] = null;
                        }
                    }
                }
            }

            clearPreview();
        }

        // Skip turn
        async function skipTurn() {
            if (game.currentPlayerIndex !== game.playerId) {
                showMessage('‚ùå ÏÉÅÎåÄÎ∞©Ïùò ÌÑ¥ÏûÖÎãàÎã§!');
                return;
            }

            if (!confirm('ÌÑ¥ÏùÑ ÎÑòÍ∏∞ÏãúÍ≤†ÏäµÎãàÍπå?')) {
                return;
            }

            game.passCount++;

            // Check if both players passed
            if (game.passCount >= 2) {
                // Mark game as over
                try {
                    const gameStateRef = window.firebaseDB.ref(window.firebaseDB.database, `rooms/${game.roomCode}/gameState/gameOver`);
                    await window.firebaseDB.set(gameStateRef, true);
                    await syncGameState();
                } catch (error) {
                    console.error('Failed to end game:', error);
                    showMessage('‚ùå Í≤åÏûÑ Ï¢ÖÎ£å Ïã§Ìå®');
                }
                return;
            }

            game.currentPlayerIndex = (game.currentPlayerIndex + 1) % 2;

            try {
                await syncGameState();
                showMessage('‚è≠Ô∏è ÌÑ¥ÏùÑ ÎÑòÍ≤ºÏäµÎãàÎã§.');
            } catch (error) {
                console.error('Failed to skip turn:', error);
                showMessage('‚ùå ÌÑ¥ ÎÑòÍ∏∞Í∏∞ Ïã§Ìå®');
                // Rollback
                game.passCount--;
                game.currentPlayerIndex = (game.currentPlayerIndex + 1) % 2;
            }
        }

        // ============================================================================
        // GAME END
        // ============================================================================

        function endGame() {
            const scores = game.players.map((player, index) => {
                const remainingSquares = player.pieces.reduce((sum, piece) => {
                    if (!piece.used) {
                        const shape = PIECE_SHAPES[piece.shapeIndex];
                        return sum + shape.flat().filter(cell => cell === 1).length;
                    }
                    return sum;
                }, 0);

                let score = -remainingSquares;

                const allPiecesUsed = player.pieces.every(p => p.used);
                if (allPiecesUsed) {
                    score += 15;
                    if (player.pieces[0].used) {
                        score += 5;
                    }
                }

                const isYou = index === game.playerId;
                return { player: isYou ? 'You' : 'Opponent', color: player.color, score };
            });

            scores.sort((a, b) => b.score - a.score);

            const finalScoresDiv = document.getElementById('finalScores');
            finalScoresDiv.innerHTML = scores.map((item, index) => {
                const medal = index === 0 ? 'Winner!' : 'Runner-up';
                return `
                    <div class="score-item ${item.color}">
                        ${medal} ${item.player}: ${item.score} points
                    </div>
                `;
            }).join('');

            document.getElementById('gameOverModal').classList.add('show');
        }

        // ============================================================================
        // LEAVE GAME
        // ============================================================================

        async function leaveGame() {
            if (!confirm('Are you sure you want to leave the game?')) {
                return;
            }

            // Remove listener
            if (game.dbListener) {
                // Firebase onValue returns unsubscribe function
                // We'll clean up by removing the room
            }

            // If host, delete room
            if (game.isHost && game.roomCode) {
                const roomRef = window.firebaseDB.ref(window.firebaseDB.database, `rooms/${game.roomCode}`);
                await window.firebaseDB.remove(roomRef);
            } else if (game.roomCode) {
                // Just disconnect
                const connectedRef = window.firebaseDB.ref(window.firebaseDB.database, `rooms/${game.roomCode}/players/${game.playerId}/connected`);
                await window.firebaseDB.set(connectedRef, false);
            }

            backToLobby();
        }

        function backToLobby() {
            // Reset game state
            game.roomCode = null;
            game.playerId = null;
            game.playerColor = null;
            game.isHost = false;
            game.gameStarted = false;
            game.selectedPieceIndex = null;
            game.passCount = 0;
            game.currentPlayerIndex = 0;
            game.board = Array(14).fill(null).map(() => Array(14).fill(null));

            // Hide game screen, show lobby
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('gameOverModal').classList.remove('show');
            document.getElementById('lobbyScreen').classList.remove('hidden');
            document.getElementById('createRoomView').classList.add('hidden');
            document.getElementById('joinRoomView').classList.add('hidden');
            document.getElementById('lobbyMain').classList.remove('hidden');
            document.getElementById('roomCodeInput').value = '';
        }

        // Make functions globally accessible
        window.createRoom = createRoom;
        window.showJoinInput = showJoinInput;
        window.joinRoom = joinRoom;
        window.cancelRoom = cancelRoom;
        window.cancelJoin = cancelJoin;
        window.selectPiece = selectPiece;
        window.deselectPiece = deselectPiece;
        window.rotatePiece = rotatePiece;
        window.flipPiece = flipPiece;
        window.skipTurn = skipTurn;
        window.leaveGame = leaveGame;
        window.backToLobby = backToLobby;

        console.log('Multiplayer Blokus initialized');
    </script>
</body>
</html>
